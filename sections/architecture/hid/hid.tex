\subsection{HID Manager}
Almost all games must have a interaction with the player, to that work a game engine must manage the human interfaces devices (HID) connected to be able to receive inputs from players\cite{GameEngineArchitecture}. There are several kinds of input devices such as Joysticks, Keyboard and Mouses, the engine must receive and handle those inputs and redirect those commands for the correct place, the redirection can be implemented using the event system described in the section \ref{sec:events}\cite{GameProgrammingPatterns}. Several input events can come from a single game frame, so the HID manager must keep a pool of those inputs that has fired in that specific frame and dispatch them in the right moment\cite{GameEngineArchitecture}. There are some types of input data such as buttons that are generally treated as on and off and analog stickers that can be treated as 2D vectors containing the positions for both vertical and horizontal axis. The main functionalities that a HID manager must provide are input dead zones\footnote{"Dead zones are simply a minimum input threshold, often somewhere between 0.1 to 0.2. If the input received from the stick is smaller than that, itâ€™s ignored."\cite{DeadZones}}, analog signal filtering, input event detection, management of multiple HIDs for multiple players, multi-platform HID support and controller input remapping that can be done using the command\footnote{"Encapsulate a request as an object, thereby letting users parameterize clients with different requests, queue or log requests, and support undoable operations."\cite{GameProgrammingPatterns}} design pattern\cite{GameEngineArchitecture, GameProgrammingPatterns}.