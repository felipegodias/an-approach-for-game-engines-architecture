\subsection{Rendering}
This probably is the most important feature for modern game engines, rendering is a really big topic to cover\cite{GameEngineArchitecture} and has become one of the most difficult software engineer project to be working with due to a large number of complex algorithms\cite{DesigningAModernRenderingEngine}. The render manager has the responsibility to send the information from the game scene to the player monitor, so it's responsible for the communication with the GPU, luckily, there's some APIs available that do a perfect job for this (e.g. OpenGL\footnote{"OpenGL is strictly defined as “a software interface to graphics hardware.” In essence, it is a 3D graphics and modeling library that is highly portable and very fast. Using OpenGL, you can create elegant and beautiful 3D graphics with exceptional visual quality. The greatest advantage to using OpenGL is that it is orders of magnitude faster than a raytracer or software rendering engine."\cite{OpenGLBible}}, DirectX\footnote{"Direct3D 12 is a rendering library for writing high-performance 3D graphics applications using modern graphics hardware on various Windows 10 platforms (Windows Desktop, Mobile, and Xbox One). Direct3D is a low-level library in the sense that its application programming interface (API) closely models the underlying graphics hardware it controls. The predominant consumer of Direct3D is the games industry, where higher level rendering engines are built on top of Direct3D."\cite{DirectX}} and Metal\footnote{"In 2014, Apple introduced a new low-level GPU programming framework for iOS: Metal. A year later, Metal came to macOS, followed by watchOS and tvOS. Apple devices have two “brains” that can be programmed to create applications: a central processing unit (CPU) and a graphics processing unit (GPU). The GPU is a specialized processor that does floating-point math in parallel very quickly and efficiently. These tasks are expensive on the CPU because they can’t be done in parallel, so various frameworks and APIs have been created to offload these expensive tasks to the processor that is best equipped to do them."\cite{Metal}}). It changes the way how the render manager will work if the game engine focus in a multi-platform development, because it now needs to choose the correct API for each operating system such as DirectX if the game is running on Windows, OpenGL if Linux or Android and Metal for Mac and iOS devices. It's also the responsibility of the render manager to manage the assets in the GPU's memory, so resources like textures, shaders and meshes\footnote{"In order to generate the necessary geometry for realtime rendering of subdivision surfaces, complete topology information is necessary for a given mesh of input polygons. Over the years a number of mesh representations have been developed that provide this topology information, given an arbitrary input mesh."\cite{AMeshDataStructureForRenderingAndSubdivision}} are not misused. Bake multiple meshes as a single one to reduce draw calls\footnote{"To draw a GameObject on the screen, the engine has to issue a draw call to the graphics API (such as OpenGL or Direct3D). Draw calls are often resource-intensive, with the graphics API doing significant work for every draw call, causing performance overhead on the CPU side. This is mostly caused by the state changes done between the draw calls (such as switching to a different Material), which causes resource-intensive validation and translation steps in the graphics driver."\cite{UnityDrawCall}} to the GPU since it has a high cost for performance.